import 'dart:io';

import 'package:localstorage/localstorage.dart';
import 'package:path/path.dart' as p;
import 'package:puter_interface/system/command_runner.dart';

class MusicPlayer {
  static Future<Map<String, String>> getNowPlaying() async {
    final raw = await CommandRunner.bash('playerctl', [
      '-p',
      'spotifyd',
      'metadata',
      '--format',
      '{{title}}|{{artist}}|{{album}}|{{mpris:artUrl}}'
    ]);

    final parts = raw.split('|');
    return {
      'title': parts.isNotEmpty ? parts[0] : '',
      'artist': parts.length > 1 ? parts[1] : '',
      'album': parts.length > 2 ? parts[2] : '',
      'artUrl': parts.length > 3 ? parts[3] : '',
    };
  }

  static Future<void> initSpotifyd() async {
    await listSpotifydProfiles();

    final String? defaultProfile = localStorage.getItem("defaultSpotifyd");
    if (profiles.contains(defaultProfile)) {
      startSpotifydWithProfile(defaultProfile!);
    } else if (profiles.isNotEmpty) {
      startSpotifydWithProfile(profiles.first);
    }
  }

  static String? profile;

  static Future<void> startSpotifydWithProfile(String profileFileName) async {
    final String home = Platform.environment['HOME'] ?? '/home/pi';
    final String confPath =
        p.join(home, '.config', 'spotifyd', 'profiles', profileFileName);

    await Process.run('pkill', ['-x', 'spotifyd']);

    await Process.start(
      'spotifyd',
      ['--config-path', confPath],
      mode: ProcessStartMode.detached,
    );

    profile = profileFileName;
  }

  static List<String> profiles = [];

  static Future<List<String>> listSpotifydProfiles() async {
    final String home = Platform.environment['HOME'] ?? '/home/pi';
    final Directory profilesDir =
        Directory(p.join(home, '.config', 'spotifyd', 'profiles'));

    if (!await profilesDir.exists()) {
      return [];
    }

    final List<String> profiles = [];
    await for (final entity in profilesDir.list(followLinks: false)) {
      if (entity is File) {
        final name = p.basename(entity.path);

        if (name.toLowerCase().endsWith('.conf')) {
          profiles.add(name);
        }
      }
    }

    profiles.sort();
    MusicPlayer.profiles = profiles;
    return profiles;
  }

  static Future<void> createSpotifydProfile({
    required String profileName,
    required Map<String, String> values,
    bool overwrite = false,
  }) async {
    final String home = Platform.environment['HOME'] ?? '/home/pi';
    final Directory profilesDir =
        Directory(p.join(home, '.config', 'spotifyd', 'profiles'));
    await profilesDir.create(recursive: true);

    String fileName = profileName.trim();
    if (fileName.isEmpty) throw ArgumentError('profileName is empty');
    if (!fileName.toLowerCase().endsWith('.conf')) fileName += '.conf';

    if (fileName.contains('/') || fileName.contains('\\')) {
      throw ArgumentError('profileName must be a simple name, not a path');
    }

    final String filePath = p.join(profilesDir.path, fileName);
    final File file = File(filePath);

    if (!overwrite && await file.exists()) {
      throw FileSystemException('Profile already exists', filePath);
    }

    String q(String s) {
      final String escaped = s
          .replaceAll(r'\', r'\\')
          .replaceAll('"', r'\"')
          .replaceAll('\n', r'\n');
      return '"$escaped"';
    }

    String formatTomlValue(String s) {
      s = s.trim();
      print(s);
      if (s == 'true' || s == 'false') return s;

      return q(s);
    }

    final buffer = StringBuffer()
      ..writeln('# Generated by PUTER')
      ..writeln('[global]');

    const allowedKeys = [
      'username',
      'password',
      'device_name',
      'backend',
      'bitrate',
      'volume_normalisation',
      'cache_path',
      'no_audio_cache',
      'audio_format',
      'use_mpris'
    ];

    final Map<String, String> defaultValues = {
      'device_name': 'PUTER',
      'backend': 'pulseaudio',
      'use_mpris': 'true',
    };

    for (final entry in defaultValues.entries) {
      values.putIfAbsent(entry.key, () => entry.value);
    }

    for (final k in allowedKeys) {
      final v = values[k];
      if (v == null) continue;
      buffer.writeln('$k = ${formatTomlValue(v)}');
    }

    buffer.writeln();

    await file.writeAsString(buffer.toString(), flush: true);
  }

  static Future<void> deleteSpotifydProfile(String profileName) async {
    final String home = Platform.environment['HOME'] ?? '/home/pi';
    String name = profileName.trim();
    if (!name.toLowerCase().endsWith('.conf')) name += '.conf';

    if (name.contains('/') || name.contains('\\')) {
      throw ArgumentError('Invalid profile name');
    }

    final File file = File(
      p.join(home, '.config', 'spotifyd', 'profiles', name),
    );

    if (await file.exists()) {
      await file.delete();
    }
  }

  static Future<void> setVolumePercent(int pct) => CommandRunner.bash(
      'pactl', ['set-sink-volume', '@DEFAULT_SINK@', '$pct%']);

  static Future<void> toggleMute() => CommandRunner.bash(
      'pactl', ['set-sink-mute', '@DEFAULT_SINK@', 'toggle']);

  static Future<void> nextTrack() =>
      CommandRunner.bash('playerctl', ['-p', 'spotifyd', 'next']);

  static Future<void> prevTrack() =>
      CommandRunner.bash('playerctl', ['-p', 'spotifyd', 'previous']);

  static Future<void> playTrack() =>
      CommandRunner.bash('playerctl', ['-p', 'spotifyd', 'play']);

  static Future<void> pauseTrack() =>
      CommandRunner.bash('playerctl', ['-p', 'spotifyd', 'pause']);

  static Future<void> togglePlay() =>
      CommandRunner.bash('playerctl', ['-p', 'spotifyd', 'play-pause']);

  static Future<void> seekTo(Duration position) async {
    final double seconds = position.inMilliseconds / 1000.0;
    await Process.run(
      'playerctl',
      ['-p', 'spotifyd', 'position', seconds.toStringAsFixed(2)],
    );
  }
}
