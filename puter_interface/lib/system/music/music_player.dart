import 'dart:async';
import 'dart:convert';
import 'dart:io';

import 'package:localstorage/localstorage.dart';
import 'package:path/path.dart' as p;
import 'package:puter_interface/system/command_runner.dart';

class MusicPlayer {
  static Future<Map<String, String>> getNowPlaying() async {
    final raw = await CommandRunner.bash('playerctl', [
      '-p',
      'spotifyd',
      'metadata',
      '--format',
      '{{title}}|{{artist}}|{{album}}|{{mpris:artUrl}}'
    ]);

    final parts = raw.split('|');
    return {
      'title': parts.isNotEmpty ? parts[0] : '',
      'artist': parts.length > 1 ? parts[1] : '',
      'album': parts.length > 2 ? parts[2] : '',
      'artUrl': parts.length > 3 ? parts[3] : '',
    };
  }

  static Future<void> initSpotifyd() async {
    await listSpotifydProfiles();

    final String? defaultProfile = localStorage.getItem("defaultSpotifyd");
    if (profiles.contains(defaultProfile)) {
      await startSpotifydWithProfile(defaultProfile!);
    } else if (profiles.isNotEmpty) {
      await startSpotifydWithProfile(profiles.first);
    }
  }

  static String? profile;

  static Future<void> startSpotifydWithProfile(String profileFileName) async {
    final String home = Platform.environment['HOME'] ?? '/home/pi';
    final String confPath =
        p.join(home, '.config', 'spotifyd', 'profiles', profileFileName);

    await Process.run('pkill', ['-x', 'spotifyd']);

    await Process.start(
      'spotifyd',
      ['--config-path', confPath],
      mode: ProcessStartMode.detached,
    );

    profile = profileFileName;
  }

  static List<String> profiles = [];

  static Future<List<String>> listSpotifydProfiles() async {
    final String home = Platform.environment['HOME'] ?? '/home/pi';
    final Directory profilesDir =
        Directory(p.join(home, '.config', 'spotifyd', 'profiles'));

    if (!await profilesDir.exists()) {
      return [];
    }

    final List<String> profiles = [];
    await for (final entity in profilesDir.list(followLinks: false)) {
      if (entity is File) {
        final name = p.basename(entity.path);

        if (name.toLowerCase().endsWith('.conf')) {
          profiles.add(name);
        }
      }
    }

    profiles.sort();
    MusicPlayer.profiles = profiles;
    return profiles;
  }


  static Future<void> createSpotifydProfile({
    required String profileName,
    bool overwrite = false,
    Duration timeout = const Duration(minutes: 3),
  }) async {
    final String home = Platform.environment['HOME'] ?? '/home/pi';

    final Directory profilesDir =
    Directory(p.join(home, '.config', 'spotifyd', 'profiles'));
    await profilesDir.create(recursive: true);

    String fileName = profileName.trim();
    if (fileName.isEmpty) throw ArgumentError('profileName is empty');
    if (!fileName.toLowerCase().endsWith('.conf')) fileName += '.conf';

    if (fileName.contains('/') || fileName.contains('\\')) {
      throw ArgumentError('profileName must be a simple name, not a path');
    }

    final String confPath = p.join(profilesDir.path, fileName);
    final File confFile = File(confPath);

    if (!overwrite && await confFile.exists()) {
      throw FileSystemException('Profile already exists', confPath);
    }

    final String profileId = fileName.substring(0, fileName.length - 5);

    final String cachePath = p.join(home, '.cache', 'spotifyd', profileId);

    final Directory oauthDir = Directory(p.join(cachePath, 'oauth'));
    await oauthDir.create(recursive: true);

    final File credsFile = File(p.join(cachePath, 'oauth', 'credentials.json'));

    String q(String s) {
      final escaped = s
          .replaceAll(r'\', r'\\')
          .replaceAll('"', r'\"')
          .replaceAll('\n', r'\n');
      return '"$escaped"';
    }

    final buffer = StringBuffer()
      ..writeln('# Generated by PUTER')
      ..writeln('[global]')
      ..writeln('device_name = "PUTER"')
      ..writeln('backend = "pulseaudio"')
      ..writeln('use_mpris = true')
      ..writeln('cache_path = ${q(cachePath)}')
      ..writeln();
    
    await confFile.writeAsString(buffer.toString(), flush: true);

    if (await credsFile.exists()) return;

    await Process.run('pkill', ['-x', 'spotifyd']);
    
    final candidates = <List<String>>[
      ['authenticate', '--config-path', confPath],
      ['authenticate'],
      ['auth', '--config-path', confPath],
      ['auth'],
    ];

    Process? proc;
    List<String>? usedArgs;
    for (final args in candidates) {
      try {
        proc = await Process.start(
          'spotifyd',
          args,
          runInShell: true,
        );
        usedArgs = args;
        print(args);
        break;
      } catch (_) {}
    }

    if (proc == null) {
      throw Exception('Failed to start spotifyd authenticate/auth. Is spotifyd in PATH?');
    }
    
    final urlRegex = RegExp(r'(https?://\S+)');
    StreamSubscription<String>? outSub;
    StreamSubscription<String>? errSub;
    final completer = Completer<void>();

    void finishOk() {
      if (!completer.isCompleted) completer.complete();
    }

    void finishErr(Object e) {
      if (!completer.isCompleted) completer.completeError(e);
    }

    // Watch stdout for an auth URL and try to open it
    outSub = proc.stdout
        .transform(utf8.decoder)
        .transform(const LineSplitter())
        .listen((line) async {
      final m = urlRegex.firstMatch(line);
      if (m != null) {
        final url = m.group(1)!;
        try {
          await Process.start('xdg-open', [url], runInShell: true);
        } catch (_) {
          // Headless? Then show the URL in your UI (you can store it somewhere).
        }
      }
    }) as StreamSubscription<String>?;

    // Optional: consume stderr (you could log it)
    errSub = proc.stderr
        .transform(utf8.decoder)
        .transform(const LineSplitter())
        .listen((_) {});

    // Poll for credentials.json creation
    final pollTimer = Timer.periodic(const Duration(milliseconds: 400), (_) async {
      try {
        if (await credsFile.exists()) finishOk();
      } catch (e) {
        finishErr(e);
      }
    });

    try {
      await completer.future.timeout(timeout);
    } on TimeoutException {
      proc.kill(ProcessSignal.sigterm);
      throw TimeoutException(
        'Timed out waiting for Spotify OAuth. Command: spotifyd ${usedArgs?.join(" ") ?? ""}',
        timeout,
      );
    } finally {
      pollTimer.cancel();
      await outSub?.cancel();
      await errSub?.cancel();
      proc.kill(ProcessSignal.sigterm);
    }
  }


  static Future<void> deleteSpotifydProfile(String profileName) async {
    final String home = Platform.environment['HOME'] ?? '/home/pi';
    String name = profileName.trim();
    if (!name.toLowerCase().endsWith('.conf')) name += '.conf';

    if (name.contains('/') || name.contains('\\')) {
      throw ArgumentError('Invalid profile name');
    }

    final File file = File(
      p.join(home, '.config', 'spotifyd', 'profiles', name),
    );

    if (await file.exists()) await file.delete();

    final profileId = name.substring(0, name.length - 5);
    final cacheDir = Directory(p.join(home, '.cache', 'spotifyd', profileId));
    if (await cacheDir.exists()) await cacheDir.delete(recursive: true);
  }

  static Future<void> setVolumePercent(int pct) => CommandRunner.bash(
      'pactl', ['set-sink-volume', '@DEFAULT_SINK@', '$pct%']);

  static Future<void> toggleMute() => CommandRunner.bash(
      'pactl', ['set-sink-mute', '@DEFAULT_SINK@', 'toggle']);

  static Future<void> nextTrack() =>
      CommandRunner.bash('playerctl', ['-p', 'spotifyd', 'next']);

  static Future<void> prevTrack() =>
      CommandRunner.bash('playerctl', ['-p', 'spotifyd', 'previous']);

  static Future<void> playTrack() =>
      CommandRunner.bash('playerctl', ['-p', 'spotifyd', 'play']);

  static Future<void> pauseTrack() =>
      CommandRunner.bash('playerctl', ['-p', 'spotifyd', 'pause']);

  static Future<void> togglePlay() =>
      CommandRunner.bash('playerctl', ['-p', 'spotifyd', 'play-pause']);

  static Future<void> seekTo(Duration position) async {
    final double seconds = position.inMilliseconds / 1000.0;
    await Process.run(
      'playerctl',
      ['-p', 'spotifyd', 'position', seconds.toStringAsFixed(2)],
    );
  }
}
